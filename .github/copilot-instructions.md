# PPSI (KiosDarma) - AI Coding Guidelines

- App: Flutter POS across Android/iOS/Web/Desktop; clean layering enforced by folder READMEs.
- Flow: Page (UI entry) → Controller (ChangeNotifier, state only) → Service (stateless business/Firebase) → Model (data + fromFirebase/toFirebase). No Firebase from controllers/pages; no state in services; pages initialize controllers via ChangeNotifierProvider.
- Firebase: All data under users/{uid}/ using DatabaseService._getUserRef(path); never touch global paths. Sensitive operations log via DatabaseService._logAuditEvent().
- Models: Plain data with factory fromFirebase(Map<String,dynamic>) and toFirebase() excluding id; allow light computed fields (isLowStock, stockStatus) only.
- Services: Stateless, single responsibility (auth, storage, payments, etc.). Wrap errors with toAppException(error, fallbackMessage: '...') from error_helper.dart; keep user messages Indonesian.
- Controllers: Must notifyListeners() after state changes and dispose subscriptions/timers (connectivity, streams, printer, etc.). Keep state immutable (private fields + getters); no UI logic.
- UI: Widgets grouped per feature under lib/widgets; keep reusable and dumb. Pages stay thin (routing + controller wiring). Use AppTheme (lib/themes/app_theme.dart) and ResponsiveHelper (lib/utils/responsive_helper.dart); avoid hardcoded colors.
- UX text: All user-facing strings Indonesian. Use snackbar_helper.dart for surfacing errors; do not expose Firebase/raw codes.
- Formatting: Use FormatUtils for currency/date with id_ID; call initializeDateFormatting('id_ID', null) early in main.dart. Currency output prefixed Rp with thousand separators.
- Connectivity/offline: Controllers listen to streams (e.g., database, connectivity_plus); cancel in dispose. Map SocketException to OfflineException via error_helper.
- Payments: XenditService requires .env (XENDIT_SECRET_KEY, XENDIT_PUBLIC_KEY). Do not hardcode keys; load dotenv before Firebase/Xendit init.
- Printing/receipts: ReceiptService + PrinterCommands handle ESC/POS; PrinterController manages device state (Bluetooth/USB). Keep printing logic out of UI.
- Data export: ReportExportService/DataExportService for Excel/PDF; keep date/currency formatting consistent.
- Storage: StorageService stores product images under products/{userId}/; respect Firebase Storage rules.
- Security: Encrypt sensitive payloads via SecurityUtils; keep AppException subclasses in app_exception.dart.
- Routing: Routes configured in lib/routes/app_routes.dart using /path strings (e.g., /kasir, /produk).
- Build/run: flutter pub get; ensure .env present; flutter run for dev. Windows release: build_apk.bat or flutter build apk --release. iOS: flutter build ios --release.
- Tooling: Flutter 3.9.2+/Dart 3.9.2+. Firebase CLI for rules deploy; do not commit .env.
- Quick file map: Auth/Login (AuthService, LoginController, pages/login_page.dart); Products (ProductService, ProductController, models/product_model.dart, widgets/products/); Kasir/Transactions (KasirController, receipt_service.dart, transaction_model.dart); Notifications (NotificationController, widgets/notifications/); Settings/Printer (SettingsService, PrinterController, PrinterCommands, pages/settings_page.dart).
- When adding features: Follow model → service → controller → widgets → page → register route in app_routes.dart. Keep new helpers in utils/ with clear naming *_utils.dart or *_helper.dart.
- Tests: None present; prioritize unit tests for utils/formatting and widget tests for reusable components when adding coverage.
